use std::net::{IpAddr, Ipv4Addr};

use anyhow::Result;
use futures::{future, prelude::*};
use log::info;
use tarpc::{
    context::Context,
    server::{self, Channel, incoming::Incoming},
    tokio_serde::formats::Json,
};

use crate::channel_service::ChannelService;

#[derive(Clone)]
pub struct Server {
    port: u16,
    // request: Box<dyn FnMut(In) -> Out>,
}

impl Server {
    pub async fn listen(port: u16) -> Result<()> {
        let server_addr = (IpAddr::V4(Ipv4Addr::UNSPECIFIED), port);

        let mut listener = tarpc::serde_transport::tcp::listen(&server_addr, Json::default).await?;

        info!("Listening on port {}", listener.local_addr().port());
        listener.config_mut().max_frame_length(usize::MAX);
        listener
            // Ignore accept errors.
            .filter_map(|r| future::ready(r.ok()))
            .map(server::BaseChannel::with_defaults)
            // Limit channels to 1 per IP.
            .max_channels_per_key(1, |t| t.transport().peer_addr().unwrap().ip())
            // serve is generated by the service attribute. It takes as input any type implementing
            // the generated World trait.
            .map(|channel| {
                let server = Self { port };
                channel.execute(server.serve()).for_each(spawn)
            })
            // Max 10 channels.
            .buffer_unordered(10)
            .for_each(|_| async {})
            .await;

        Ok(())
    }
}

impl ChannelService for Server {
    async fn send_data(self, context: Context, data: String) -> String {
        dbg!("Sobok");

        String::default()
    }
}

async fn spawn(fut: impl Future<Output = ()> + Send + 'static) {
    tokio::spawn(fut);
}
